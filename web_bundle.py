import sys
import types
utils_src = 'def fix_zero(value, eps=1e-12):\n    return 0.0 if abs(value) < eps else value'
parsing_src = 'import re\nimport ast\n\ndef split_equation(equation: str) -> tuple[str, str]:\n  """\n  Splits an equation string into its left and right-hand sides.\n\n  Args:\n    equation (str): The full equation string (e.g., "2x + 3 = 7").\n\n  Returns:\n    tuple[str, str]: A tuple containing the left-hand side and right-hand side as strings.\n\n  Raises:\n    ValueError:\n      - If the equation does not contain exactly one \'=\' sign.\n      - If either side of the equation is empty after stripping whitespace.\n  """\n\n  eq = equation.strip()\n\n  # Match \'=\' that is not part of \'>=\' or \'<=\'.\n  match = re.search(r"(?<![<>])=(?!=)", eq)\n  if not match:\n    raise ValueError("Equation must contain exactly one \'=\' sign.")\n  if re.search(r"(?<![<>])=(?!=)", eq[match.end():]):\n    raise ValueError("Equation must contain exactly one \'=\' sign.")\n\n  split_at = match.start()\n  lhs, rhs = eq[:split_at], eq[split_at + 1:]\n\n  lhs = lhs.strip()\n  rhs = rhs.strip()\n\n  if lhs == "" or rhs == "":\n    raise ValueError("Both sides of the equation must be non-empty.")\n\n  return equation_strip(lhs, rhs)\n\ndef split_equalities(equation: str) -> list[str]:\n  """\n  Splits chained equalities like "x = y = z" into ["x = y", "y = z"].\n  """\n  eq = equation.strip()\n  matches = list(re.finditer(r"(?<![<>])=(?!=)", eq))\n  if len(matches) <= 1:\n    return [eq]\n  parts = []\n  start = 0\n  for m in matches:\n    parts.append(eq[start:m.start()])\n    start = m.end()\n  parts.append(eq[start:])\n\n  exprs = [p.strip() for p in parts]\n  if any(p == "" for p in exprs):\n    raise ValueError("Both sides of the equation must be non-empty.")\n  return [f"{exprs[i]} = {exprs[i + 1]}" for i in range(len(exprs) - 1)]\n\ndef split_inequality(equation: str) -> tuple[list[str], list[str]]:\n  """\n  Splits an inequality string into segments (expr, op, expr), supporting chaining.\n\n  Args:\n    equation (str): The full inequality string (e.g., "2x + 3 <= 7").\n\n  Returns:\n    tuple[list[str], list[str]]: list of expressions and list of operators.\n\n  Raises:\n    ValueError:\n      - If the inequality does not contain exactly one comparison operator.\n      - If either side of the inequality is empty after stripping whitespace.\n  """\n  eq = equation.strip()\n  parts = re.split(r"(<=|>=|<|>)", eq)\n  if len(parts) < 3:\n    raise ValueError("Inequality must contain at least one comparison operator.")\n\n  exprs = [parts[i].strip() for i in range(0, len(parts), 2)]\n  ops = [parts[i].strip() for i in range(1, len(parts), 2)]\n  if len(exprs) != len(ops) + 1:\n    raise ValueError("Malformed inequality.")\n\n  exprs = [equation_strip(e, e)[0] for e in exprs]\n  return exprs, ops\n\ndef equation_strip(lhs: str, rhs: str) -> tuple[str, str]:\n\n    lhs = lhs.replace(" ", "")\n    rhs = rhs.replace(" ", "")\n\n    if lhs == "" or rhs == "":\n        raise ValueError("Both sides of the equation must be non-empty.")\n\n    combined = lhs + rhs\n\n    if any(not (char.isalnum() or char in "+-*/.()^<>=,") for char in combined):\n        raise ValueError("Equation contains invalid characters.")\n\n    return lhs, rhs\n\ndef normalize(expr: str) -> str:\n  """\n  Normalizes an algebraic expression by removing spaces and adding a leading \'+\'\n  if the first character is not a sign.\n\n  Args:\n    expr (str): The algebraic expression string.\n\n  Returns:\n    str: The normalized expression.\n  """\n  expr = expr.replace(" ", "")\n\n  if expr[0] not in "+-":\n    expr = "+" + expr\n\n  return expr\n\ndef split_terms(expr: str) -> list[str]:\n  """\n  Splits an algebraic expression into individual terms based on \'+\' or \'-\' signs.\n  For example, "+2x-3" becomes ["+2x", "-3"].\n\n  Args:\n    expr (str): The algebraic expression string.\n\n  Returns:\n    list[str]: A list of terms, each including its leading sign.\n  """\n  terms = []\n  start = 0\n\n  for i in range(1, len(expr)):\n    if expr[i] in "+-":\n      terms.append(expr[start:i])\n      start = i\n\n  terms.append(expr[start:])\n  return terms\n\ndef parse_expr(expr: str) -> ast.expr:\n    """\n    Parses an algebraic expression string into an AST node.\n\n    Args:\n        expr (str): The algebraic expression string.\n\n    Returns:\n        ast.AST: The root AST node representing the expression.\n    """\n    expr = insert_implicit_mul(expr)\n    expr = expr.replace("^", "**")\n    tree = ast.parse(expr, mode="eval")\n    return tree.body\n\ndef insert_implicit_mul(expr: str) -> str:\n    """\n    Inserts explicit multiplication operators in an algebraic expression where multiplication is implied (e.g., between a number and a variable).\n\n    Args:\n        expr (str): The algebraic expression string.\n\n    Returns:\n        str: The expression with explicit multiplication operators.\n    """\n\n    expr = expr.replace(" ", "")\n    expr = re.sub(r\'(\\d)([A-Za-z])(?![A-Za-z])\', r\'\\1*\\2\', expr)\n    expr = re.sub(r\'(\\d)(\\()\', r\'\\1*\\2\', expr)\n    expr = re.sub(r\'(?<![A-Za-z])([A-Za-z])(\\d|\\()\', r\'\\1*\\2\', expr)\n    expr = re.sub(r\'(\\))([A-Za-z])(?![A-Za-z])\', r\'\\1*\\2\', expr)\n    expr = re.sub(r\'(\\))(\\()\', r\'\\1*\\2\', expr)\n    return expr\n\ndef linearize_ast(node) -> tuple[float, float]:\n    """\n    Converts an AST node representing a linear expression into its coefficients (a, b) for the form a*x + b.\n\n    Args:\n        node: An AST node representing the expression.\n    Returns:\n        tuple[float, float]:\n            A tuple (a, b) representing the coefficients of the linear expression a*x + b.\n    """\n    # returns (a, b) for a*x + b\n    if isinstance(node, ast.Constant):\n        if not isinstance(node.value, (int, float)):\n            raise ValueError("Only numeric constants supported.")\n        return 0.0, float(node.value)\n    \n    # Handle variable \'x\'\n    if isinstance(node, ast.Name):\n        if node.id != "x":\n            raise ValueError("Only \'x\' is supported.")\n        return 1.0, 0.0\n\n    # Handle unary operations\n    if isinstance(node, ast.UnaryOp):\n        a, b = linearize_ast(node.operand)\n        if isinstance(node.op, ast.USub):\n            return -a, -b\n        if isinstance(node.op, ast.UAdd):\n            return a, b\n        raise ValueError("Unsupported unary operator.")\n    \n    # Handle function calls (only abs supported)\n    if isinstance(node, ast.Call):\n        if not isinstance(node.func, ast.Name) or node.func.id != "abs":\n            raise ValueError("Only abs() is supported.")\n        if len(node.args) != 1:\n            raise ValueError("abs() takes exactly one argument.")\n        a, b = linearize_ast(node.args[0])\n        if a != 0.0:\n            raise ValueError("abs() with x is not supported for linear solver.")\n        return 0.0, abs(b)\n\n    # Handle binary operations\n    if isinstance(node, ast.BinOp):\n        a1, b1 = linearize_ast(node.left)\n        a2, b2 = linearize_ast(node.right)\n\n        if isinstance(node.op, ast.Add):\n            return a1 + a2, b1 + b2\n        if isinstance(node.op, ast.Sub):\n            return a1 - a2, b1 - b2\n        if isinstance(node.op, ast.Mult):\n            # nonlinear if both sides have x\n            if a1 != 0.0 and a2 != 0.0:\n                raise ValueError("Nonlinear term in multiplication.")\n            if a2 == 0.0:\n                return a1 * b2, b1 * b2\n            return a2 * b1, b2 * b1\n        if isinstance(node.op, ast.Div):\n            if a2 != 0.0:\n                raise ValueError("Nonlinear term in division.")\n            if b2 == 0.0:\n                raise ZeroDivisionError("Division by zero.")\n            return a1 / b2, b1 / b2\n        if isinstance(node.op, ast.Pow):\n            if a1 != 0.0 or a2 != 0.0:\n                raise ValueError("Exponentiation with x is not supported.")\n            return 0.0, b1 ** b2\n\n        raise ValueError("Unsupported binary operator.")\n    raise ValueError("Unsupported expression node.")\n\ndef quadraticize_ast(node) -> tuple[float, float, float]:\n    """\n    Converts an AST node into quadratic coefficients (a, b, c) for a*x^2 + b*x + c.\n    Supports +, -, *, / with constants and x, and x^2.\n    """\n    def add_poly(p, q):\n        return (p[0] + q[0], p[1] + q[1], p[2] + q[2])\n\n    def sub_poly(p, q):\n        return (p[0] - q[0], p[1] - q[1], p[2] - q[2])\n\n    def mul_poly(p, q):\n        # (c0 + c1*x + c2*x^2) * (d0 + d1*x + d2*x^2)\n        c0, c1, c2 = p\n        d0, d1, d2 = q\n        # Compute up to degree 2, reject higher-degree terms.\n        deg3 = c1 * d2 + c2 * d1\n        deg4 = c2 * d2\n        if deg3 != 0.0 or deg4 != 0.0:\n            raise ValueError("Polynomial degree greater than 2 is not supported.")\n        return (\n            c0 * d0,\n            c0 * d1 + c1 * d0,\n            c0 * d2 + c1 * d1 + c2 * d0,\n        )\n\n    def div_poly(p, q):\n        # Only allow division by constant.\n        if q[1] != 0.0 or q[2] != 0.0:\n            raise ValueError("Division by non-constant is not supported.")\n        if q[0] == 0.0:\n            raise ZeroDivisionError("Division by zero.")\n        return (p[0] / q[0], p[1] / q[0], p[2] / q[0])\n\n    if isinstance(node, ast.Constant):\n        if not isinstance(node.value, (int, float)):\n            raise ValueError("Only numeric constants supported.")\n        return (float(node.value), 0.0, 0.0)\n\n    if isinstance(node, ast.Name):\n        if node.id != "x":\n            raise ValueError("Only \'x\' is supported.")\n        return (0.0, 1.0, 0.0)\n\n    if isinstance(node, ast.UnaryOp):\n        a, b, c = quadraticize_ast(node.operand)\n        if isinstance(node.op, ast.USub):\n            return (-a, -b, -c)\n        if isinstance(node.op, ast.UAdd):\n            return (a, b, c)\n        raise ValueError("Unsupported unary operator.")\n\n    if isinstance(node, ast.BinOp):\n        left = quadraticize_ast(node.left)\n        right = quadraticize_ast(node.right)\n\n        if isinstance(node.op, ast.Add):\n            return add_poly(left, right)\n        if isinstance(node.op, ast.Sub):\n            return sub_poly(left, right)\n        if isinstance(node.op, ast.Mult):\n            return mul_poly(left, right)\n        if isinstance(node.op, ast.Div):\n            return div_poly(left, right)\n        if isinstance(node.op, ast.Pow):\n            # Only allow constant exponents; x^2 supported.\n            if right[1] != 0.0 or right[2] != 0.0:\n                raise ValueError("Exponent must be constant.")\n            exp = right[0]\n            if exp == 2:\n                return mul_poly(left, left)\n            if exp == 1:\n                return left\n            if exp == 0:\n                return (1.0, 0.0, 0.0)\n            raise ValueError("Only exponent 2 is supported for x.")\n\n        raise ValueError("Unsupported binary operator.")\n\n    raise ValueError("Unsupported expression node.")\n\ndef linearize_multi_ast(node) -> tuple[dict, float]:\n    """\n    Converts an AST node into linear coefficients for multiple variables.\n    Returns (coeffs, constant) for sum(coeffs[var] * var) + constant.\n    """\n    def add(c1, k1, c2, k2):\n        coeffs = dict(c1)\n        for key, val in c2.items():\n            coeffs[key] = coeffs.get(key, 0.0) + val\n        return coeffs, k1 + k2\n\n    def sub(c1, k1, c2, k2):\n        coeffs = dict(c1)\n        for key, val in c2.items():\n            coeffs[key] = coeffs.get(key, 0.0) - val\n        return coeffs, k1 - k2\n\n    def scale(coeffs, k, factor):\n        return {v: c * factor for v, c in coeffs.items()}, k * factor\n\n    if isinstance(node, ast.Constant):\n        if not isinstance(node.value, (int, float)):\n            raise ValueError("Only numeric constants supported.")\n        return {}, float(node.value)\n\n    if isinstance(node, ast.Name):\n        return {node.id: 1.0}, 0.0\n\n    if isinstance(node, ast.UnaryOp):\n        coeffs, k = linearize_multi_ast(node.operand)\n        if isinstance(node.op, ast.USub):\n            return scale(coeffs, k, -1.0)\n        if isinstance(node.op, ast.UAdd):\n            return coeffs, k\n        raise ValueError("Unsupported unary operator.")\n\n    if isinstance(node, ast.BinOp):\n        c1, k1 = linearize_multi_ast(node.left)\n        c2, k2 = linearize_multi_ast(node.right)\n\n        if isinstance(node.op, ast.Add):\n            return add(c1, k1, c2, k2)\n        if isinstance(node.op, ast.Sub):\n            return sub(c1, k1, c2, k2)\n        if isinstance(node.op, ast.Mult):\n            if c1 and c2:\n                raise ValueError("Nonlinear term detected in multiplication.")\n            if c2:\n                return scale(c2, k2, k1)\n            return scale(c1, k1, k2)\n        if isinstance(node.op, ast.Div):\n            if c2:\n                raise ValueError("Division by non-constant is not supported.")\n            if k2 == 0.0:\n                raise ZeroDivisionError("Division by zero.")\n            return scale(c1, k1, 1.0 / k2)\n\n        raise ValueError("Unsupported binary operator.")\n\n    if isinstance(node, ast.Call):\n        raise ValueError("Functions are not supported in multi-variable linearization.")\n\n    raise ValueError("Unsupported expression node.")\n\ndef polynomialize_ast(node) -> list[float]:\n    """\n    Converts an AST node into polynomial coefficients [c0, c1, ..., cn] for\n    c0 + c1*x + ... + cn*x^n.\n    """\n    def add_poly(p, q):\n        size = max(len(p), len(q))\n        out = [0.0] * size\n        for i in range(size):\n            out[i] = (p[i] if i < len(p) else 0.0) + (q[i] if i < len(q) else 0.0)\n        return out\n\n    def sub_poly(p, q):\n        size = max(len(p), len(q))\n        out = [0.0] * size\n        for i in range(size):\n            out[i] = (p[i] if i < len(p) else 0.0) - (q[i] if i < len(q) else 0.0)\n        return out\n\n    def mul_poly(p, q):\n        out = [0.0] * (len(p) + len(q) - 1)\n        for i, a in enumerate(p):\n            for j, b in enumerate(q):\n                out[i + j] += a * b\n        return out\n\n    def div_poly(p, q):\n        if len(q) != 1:\n            raise ValueError("Division by non-constant is not supported.")\n        if q[0] == 0.0:\n            raise ZeroDivisionError("Division by zero.")\n        return [coef / q[0] for coef in p]\n\n    def pow_poly(p, exp):\n        if exp < 0:\n            raise ValueError("Negative exponents are not supported.")\n        if exp == 0:\n            return [1.0]\n        result = [1.0]\n        base = p[:]\n        power = exp\n        while power > 0:\n            if power % 2 == 1:\n                result = mul_poly(result, base)\n            base = mul_poly(base, base)\n            power //= 2\n        return result\n\n    if isinstance(node, ast.Constant):\n        if not isinstance(node.value, (int, float)):\n            raise ValueError("Only numeric constants supported.")\n        return [float(node.value)]\n\n    if isinstance(node, ast.Name):\n        if node.id != "x":\n            raise ValueError("Only \'x\' is supported.")\n        return [0.0, 1.0]\n\n    if isinstance(node, ast.UnaryOp):\n        poly = polynomialize_ast(node.operand)\n        if isinstance(node.op, ast.USub):\n            return [-c for c in poly]\n        if isinstance(node.op, ast.UAdd):\n            return poly\n        raise ValueError("Unsupported unary operator.")\n\n    if isinstance(node, ast.BinOp):\n        left = polynomialize_ast(node.left)\n        right = polynomialize_ast(node.right)\n\n        if isinstance(node.op, ast.Add):\n            return add_poly(left, right)\n        if isinstance(node.op, ast.Sub):\n            return sub_poly(left, right)\n        if isinstance(node.op, ast.Mult):\n            return mul_poly(left, right)\n        if isinstance(node.op, ast.Div):\n            return div_poly(left, right)\n        if isinstance(node.op, ast.Pow):\n            if len(right) != 1:\n                raise ValueError("Exponent must be constant.")\n            exp = right[0]\n            if not float(exp).is_integer():\n                raise ValueError("Exponent must be an integer.")\n            return pow_poly(left, int(exp))\n\n        raise ValueError("Unsupported binary operator.")\n\n    raise ValueError("Unsupported expression node.")\n\ndef reduce_linear(expr: str) -> tuple[float, float]:\n    \'\'\'\n    Reduces a linear algebraic expression into the coefficients of \'x\' and the constant term.\n    Supports terms like 4x, -x, +x, 3*x, and decimals.\n\n    Args:\n        expr (str): The algebraic expression string.\n    \n    Returns:\n        tuple[float, float]: \n            A tuple (a, b) where \'a\' is the coefficient of \'x\' and \'b\' is the constant term. \n    \'\'\'\n    node = parse_expr(expr)\n    return linearize_ast(node)\n\ndef find_abs_calls(node):\n    """\n    Finds all abs() function calls in an AST node. This is useful for identifying absolute value expressions in an equation and includes their arguments for further processing.\n\n    Args:\n        node: An AST node representing the expression.\n    Returns:\n        list: A list of AST nodes that are arguments to abs() function calls.\n    """\n    found = []\n\n    def visit(n):\n        if isinstance(n, ast.Call):\n            if isinstance(n.func, ast.Name) and n.func.id == "abs" and len(n.args) == 1:\n                found.append(n.args[0])\n            # keep walking call args too\n            for arg in n.args:\n                visit(arg)\n            return\n\n        # Walk binary/unary/other expression nodes\n        if isinstance(n, ast.BinOp):\n            visit(n.left)\n            visit(n.right)\n        elif isinstance(n, ast.UnaryOp):\n            visit(n.operand)\n        elif isinstance(n, ast.BoolOp):\n            for v in n.values:\n                visit(v)\n        elif isinstance(n, ast.Compare):\n            visit(n.left)\n            for c in n.comparators:\n                visit(c)\n        elif isinstance(n, ast.IfExp):\n            visit(n.test)\n            visit(n.body)\n            visit(n.orelse)\n        elif isinstance(n, ast.Call):\n            # handled above\n            pass\n        # constants/names: nothing to do\n\n    visit(node)\n    return found\n\ndef build_abs_cases(expr_ast):\n    """\n    Expands abs() into piecewise cases. Returns a list of (expr_ast, constraints).\n    Each constraints entry is a list of Compare nodes to evaluate at a candidate x.\n    """\n    def expand(node):\n        if isinstance(node, ast.Call):\n            if not isinstance(node.func, ast.Name) or node.func.id != "abs":\n                raise ValueError("Only abs() calls are supported.")\n            if len(node.args) != 1:\n                raise ValueError("abs() takes one argument.")\n            inner_cases = expand(node.args[0])\n            cases = []\n            for inner_expr, inner_constraints in inner_cases:\n                pos_constraint = ast.Compare(\n                    left=inner_expr, ops=[ast.GtE()], comparators=[ast.Constant(0)]\n                )\n                neg_constraint = ast.Compare(\n                    left=inner_expr, ops=[ast.Lt()], comparators=[ast.Constant(0)]\n                )\n                cases.append((inner_expr, inner_constraints + [pos_constraint]))\n                cases.append(\n                    (ast.UnaryOp(op=ast.USub(), operand=inner_expr), inner_constraints + [neg_constraint])\n                )\n            return cases\n\n        if isinstance(node, ast.BinOp):\n            left_cases = expand(node.left)\n            right_cases = expand(node.right)\n            cases = []\n            for left_expr, left_constraints in left_cases:\n                for right_expr, right_constraints in right_cases:\n                    cases.append(\n                        (\n                            ast.BinOp(left=left_expr, op=node.op, right=right_expr),\n                            left_constraints + right_constraints,\n                        )\n                    )\n            return cases\n\n        if isinstance(node, ast.UnaryOp):\n            operand_cases = expand(node.operand)\n            return [\n                (ast.UnaryOp(op=node.op, operand=expr), constraints)\n                for expr, constraints in operand_cases\n            ]\n\n        if isinstance(node, ast.Constant) or isinstance(node, ast.Name):\n            return [(node, [])]\n\n        raise ValueError("Unsupported expression node for abs expansion.")\n\n    return expand(expr_ast)\n\ndef eval_linear_ast(node, x_value):\n    # returns numeric value of the expression at x\n    if isinstance(node, ast.Constant):\n        value = node.value\n        if not isinstance(value, (int, float)):\n            raise ValueError("Only numeric constants supported.")\n        return float(value)\n    if isinstance(node, ast.Name):\n        if node.id != "x":\n            raise ValueError("Only \'x\' is supported.")\n        return float(x_value)\n    if isinstance(node, ast.UnaryOp):\n        val = eval_linear_ast(node.operand, x_value)\n        if isinstance(node.op, ast.USub):\n            return -val\n        if isinstance(node.op, ast.UAdd):\n            return val\n        raise ValueError("Unsupported unary op.")\n    if isinstance(node, ast.BinOp):\n        left = eval_linear_ast(node.left, x_value)\n        right = eval_linear_ast(node.right, x_value)\n        if isinstance(node.op, ast.Add): return left + right\n        if isinstance(node.op, ast.Sub): return left - right\n        if isinstance(node.op, ast.Mult): return left * right\n        if isinstance(node.op, ast.Div): return left / right\n        if isinstance(node.op, ast.Pow): return left ** right\n        raise ValueError("Unsupported binary op.")\n    raise ValueError("Unsupported node.")\n\ndef eval_poly_coeffs(coeffs, x_value):\n    result = 0.0\n    for coef in reversed(coeffs):\n        result = result * x_value + coef\n    return result\n\ndef eval_expr_ast_with_env(node, env):\n    if isinstance(node, ast.Constant):\n        value = node.value\n        if not isinstance(value, (int, float)):\n            raise ValueError("Only numeric constants supported.")\n        return float(value)\n    if isinstance(node, ast.Name):\n        if node.id not in env:\n            raise ValueError(f"Unknown variable: {node.id}")\n        return float(env[node.id])\n    if isinstance(node, ast.UnaryOp):\n        val = eval_expr_ast_with_env(node.operand, env)\n        if isinstance(node.op, ast.USub):\n            return -val\n        if isinstance(node.op, ast.UAdd):\n            return val\n        raise ValueError("Unsupported unary op.")\n    if isinstance(node, ast.BinOp):\n        left = eval_expr_ast_with_env(node.left, env)\n        right = eval_expr_ast_with_env(node.right, env)\n        if isinstance(node.op, ast.Add): return left + right\n        if isinstance(node.op, ast.Sub): return left - right\n        if isinstance(node.op, ast.Mult): return left * right\n        if isinstance(node.op, ast.Div): return left / right\n        if isinstance(node.op, ast.Pow): return left ** right\n        raise ValueError("Unsupported binary op.")\n    if isinstance(node, ast.IfExp):\n        cond = eval_condition_ast_with_env(node.test, env)\n        return eval_expr_ast_with_env(node.body, env) if cond else eval_expr_ast_with_env(node.orelse, env)\n    if isinstance(node, ast.Call):\n        if not isinstance(node.func, ast.Name):\n            raise ValueError("Unsupported function call.")\n        if len(node.args) != 1:\n            if node.func.id == "piecewise":\n                return eval_piecewise_call(node, env)\n            raise ValueError("Only single-argument functions supported.")\n        import math\n        func = node.func.id\n        arg = eval_expr_ast_with_env(node.args[0], env)\n        if func == "abs":\n            return abs(arg)\n        if func == "sin":\n            return math.sin(arg)\n        if func == "cos":\n            return math.cos(arg)\n        if func == "tan":\n            return math.tan(arg)\n        if func == "log":\n            if arg <= 0:\n                raise ValueError("log() domain error.")\n            return math.log(arg)\n        if func == "exp":\n            return math.exp(arg)\n        if func == "sqrt":\n            if arg < 0:\n                raise ValueError("sqrt() domain error.")\n            return math.sqrt(arg)\n        if func == "piecewise":\n            return eval_piecewise_call(node, env)\n        raise ValueError("Unsupported function call.")\n    coeffs = polynomialize_ast(node)\n    return eval_poly_coeffs(coeffs, env.get("x", 0.0))\n\ndef eval_expr_ast(node, x_value):\n    return eval_expr_ast_with_env(node, {"x": x_value})\n\ndef eval_condition_ast_with_env(node, env):\n    if isinstance(node, ast.Compare):\n        if len(node.ops) != 1 or len(node.comparators) != 1:\n            raise ValueError("Only single comparisons supported in conditions.")\n        left = eval_expr_ast_with_env(node.left, env)\n        right = eval_expr_ast_with_env(node.comparators[0], env)\n        op = node.ops[0]\n        if isinstance(op, ast.GtE): return left >= right\n        if isinstance(op, ast.Lt): return left < right\n        if isinstance(op, ast.Gt): return left > right\n        if isinstance(op, ast.LtE): return left <= right\n        if isinstance(op, ast.Eq): return left == right\n        if isinstance(op, ast.NotEq): return left != right\n        raise ValueError("Unsupported comparison operator.")\n    if isinstance(node, ast.BoolOp):\n        if isinstance(node.op, ast.And):\n            return all(eval_condition_ast_with_env(v, env) for v in node.values)\n        if isinstance(node.op, ast.Or):\n            return any(eval_condition_ast_with_env(v, env) for v in node.values)\n        raise ValueError("Unsupported boolean operator.")\n    if isinstance(node, ast.UnaryOp) and isinstance(node.op, ast.Not):\n        return not eval_condition_ast_with_env(node.operand, env)\n    # Fallback: treat numeric expression as truthy/falsey.\n    return eval_expr_ast_with_env(node, env) != 0\n\ndef eval_condition_ast(node, x_value):\n    return eval_condition_ast_with_env(node, {"x": x_value})\n\ndef eval_piecewise_call(node, env):\n    if not isinstance(node, ast.Call) or not isinstance(node.func, ast.Name) or node.func.id != "piecewise":\n        raise ValueError("Invalid piecewise call.")\n    if len(node.args) < 3 or len(node.args) % 2 == 0:\n        raise ValueError("piecewise requires pairs of (condition, expr) plus a default expr.")\n    for i in range(0, len(node.args) - 1, 2):\n        cond = node.args[i]\n        expr = node.args[i + 1]\n        if eval_condition_ast_with_env(cond, env):\n            return eval_expr_ast_with_env(expr, env)\n    return eval_expr_ast_with_env(node.args[-1], env)\n\ndef eval_constraint(node, x_value):\n    if not isinstance(node, ast.Compare):\n        raise ValueError("Expected Compare node.")\n    if len(node.ops) != 1 or len(node.comparators) != 1:\n        raise ValueError("Only single comparisons supported.")\n    left = eval_expr_ast(node.left, x_value)\n    right = eval_expr_ast(node.comparators[0], x_value)\n    op = node.ops[0]\n    if isinstance(op, ast.GtE): return left >= right\n    if isinstance(op, ast.Lt): return left < right\n    if isinstance(op, ast.Gt): return left > right\n    if isinstance(op, ast.LtE): return left <= right\n    if isinstance(op, ast.Eq): return left == right\n    raise ValueError("Unsupported comparison.")\n\ndef get_variable_names(node):\n    names = set()\n    for n in ast.walk(node):\n        if isinstance(n, ast.Name):\n            if n.id not in {"sin", "cos", "tan", "log", "exp", "sqrt", "abs", "piecewise"}:\n                names.add(n.id)\n    return names\n\nclass _VarReplacer(ast.NodeTransformer):\n    def __init__(self, from_name, to_name):\n        self.from_name = from_name\n        self.to_name = to_name\n\n    def visit_Name(self, node):\n        if node.id == self.from_name:\n            return ast.copy_location(ast.Name(id=self.to_name, ctx=node.ctx), node)\n        return node\n\ndef replace_variable(node, from_name, to_name):\n    return _VarReplacer(from_name, to_name).visit(node)\n'
linear_src = 'import utils\nimport parsing\nfrom typing import cast\n\ndef reduce_linear(expr):\n    """\n    Reduces a linear expression to its coefficients (a, b) for the form a*x + b.\n\n    Args:\n        expr (str): The linear expression as a string.\n\n    Returns:\n        tuple[float, float]: A tuple (a, b) representing the coefficients of the linear expression a*x + b.\n    """\n    return parsing.reduce_linear(expr)\n\ndef solve_linear(equation):\n  """\n  Solves a single-variable linear equation, including abs() cases.\n  """\n\n  lhs, rhs = parsing.split_equation(equation)\n  lhs_ast = parsing.parse_expr(lhs)\n  rhs_ast = parsing.parse_expr(rhs)\n  expr_ast = parsing.ast.BinOp(\n    left=cast(parsing.ast.expr, lhs_ast),\n    op=parsing.ast.Sub(),\n    right=cast(parsing.ast.expr, rhs_ast),\n  )\n  vars_found = parsing.get_variable_names(expr_ast)\n  if len(vars_found) > 1:\n    raise ValueError("Multiple variables are not supported in a single equation.")\n  if len(vars_found) == 1 and "x" not in vars_found:\n    var_name = next(iter(vars_found))\n    expr_ast = parsing.replace_variable(expr_ast, var_name, "x")\n  cases = parsing.build_abs_cases(expr_ast)\n  if cases:\n    results = []\n    for case_expr, constraints in cases:\n      a, b = parsing.linearize_ast(case_expr)\n      solutions = solve_linear_from_coeffs(a, b)\n      for sol in solutions:\n        if sol == "ALL_REAL_NUMBERS":\n          if all(_constraint_always_true(c) for c in constraints):\n            results.append(sol)\n          continue\n        if all(parsing.eval_constraint(c, sol) for c in constraints):\n          results.append(utils.fix_zero(sol))\n    return _dedupe_and_sort(results)\n\n  aL, bL = reduce_linear(lhs)\n  aR, bR = reduce_linear(rhs)\n  a = aL - aR\n  b = bL - bR\n\n  if a != 0:\n    return _dedupe_and_sort([utils.fix_zero(-b / a)])\n\n  if b == 0:\n    return ["ALL_REAL_NUMBERS"]\n\n  return []\n\ndef solve_inequality(equation):\n  """\n  Solves a linear inequality and returns solution intervals.\n  """\n  exprs, ops = parsing.split_inequality(equation)\n  expr_asts = [parsing.parse_expr(expr) for expr in exprs]\n  intervals = [(-float("inf"), float("inf"), False, False)]\n\n  for idx, op in enumerate(ops):\n    lhs_ast = expr_asts[idx]\n    rhs_ast = expr_asts[idx + 1]\n    expr_ast = parsing.ast.BinOp(\n      left=cast(parsing.ast.expr, lhs_ast),\n      op=parsing.ast.Sub(),\n      right=cast(parsing.ast.expr, rhs_ast),\n    )\n    vars_found = parsing.get_variable_names(expr_ast)\n    if len(vars_found) > 1:\n      raise ValueError("Multiple variables are not supported in a single inequality.")\n    if len(vars_found) == 1 and "x" not in vars_found:\n      var_name = next(iter(vars_found))\n      expr_ast = parsing.replace_variable(expr_ast, var_name, "x")\n\n    cases = parsing.build_abs_cases(expr_ast)\n    if cases:\n      current = []\n      for case_expr, constraints in cases:\n        a, b = parsing.linearize_ast(case_expr)\n        case_intervals = _solve_linear_inequality_from_coeffs(a, b, op)\n        case_intervals = _filter_intervals_by_constraints(case_intervals, constraints)\n        current.extend(case_intervals)\n      intervals = _intersect_interval_lists(intervals, current)\n      continue\n\n    a, b = parsing.linearize_ast(expr_ast)\n    current = _solve_linear_inequality_from_coeffs(a, b, op)\n    intervals = _intersect_interval_lists(intervals, current)\n\n  return _merge_intervals(intervals)\n\ndef solve_inequality_system(equation):\n  """\n  Returns half-space constraints for multi-variable linear inequalities.\n  """\n  exprs, ops = parsing.split_inequality(equation)\n  expr_asts = [parsing.parse_expr(expr) for expr in exprs]\n  constraints = []\n  for idx, op in enumerate(ops):\n    lhs_ast = expr_asts[idx]\n    rhs_ast = expr_asts[idx + 1]\n    cL, kL = parsing.linearize_multi_ast(lhs_ast)\n    cR, kR = parsing.linearize_multi_ast(rhs_ast)\n    coeffs = {}\n    for key, val in cL.items():\n      coeffs[key] = coeffs.get(key, 0.0) + val\n    for key, val in cR.items():\n      coeffs[key] = coeffs.get(key, 0.0) - val\n    const = kL - kR\n    constraints.append((coeffs, op, -const))\n  return constraints\n\ndef format_halfspaces(constraints):\n  """\n  Formats constraints like "2x + y <= 3".\n  """\n  parts = []\n  for coeffs, op, rhs in constraints:\n    terms = []\n    for var in sorted(coeffs.keys()):\n      coef = coeffs[var]\n      if abs(coef) < 1e-12:\n        continue\n      sign = "+" if coef > 0 else "-"\n      mag = abs(coef)\n      coef_text = "" if abs(mag - 1.0) < 1e-9 else _fmt_number(mag)\n      terms.append(f"{sign}{coef_text}{var}")\n    if not terms:\n      left = "0"\n    else:\n      left = " ".join(terms).lstrip("+")\n    parts.append(f"{left} {op} {_fmt_number(rhs)}")\n  return " and ".join(parts)\n\ndef format_intervals(intervals):\n  if not intervals:\n    return "no solution"\n  if intervals == [(-float("inf"), float("inf"), False, False)]:\n    return "all real numbers"\n\n  parts = []\n  for low, high, inc_low, inc_high in intervals:\n    left = "[" if inc_low else "("\n    right = "]" if inc_high else ")"\n    low_text = "-∞" if low == -float("inf") else _fmt_number(low)\n    high_text = "∞" if high == float("inf") else _fmt_number(high)\n    if low == high:\n      parts.append(f"{{{low_text}}}")\n    else:\n      parts.append(f"{left}{low_text}, {high_text}{right}")\n  return " U ".join(parts)\n\ndef format_solutions(solutions):\n  if solutions == ["ALL_REAL_NUMBERS"]:\n    return "all real numbers"\n  if not solutions:\n    return "no solution"\n  if len(solutions) == 1:\n    return f"{{{_fmt_number(solutions[0])}}}"\n  return "{" + ", ".join(_fmt_number(v) for v in solutions) + "}"\n\ndef format_complex_solutions(solutions):\n  if not solutions:\n    return "no solution"\n  return "{" + ", ".join(_fmt_complex(v) for v in solutions) + "}"\n\ndef _constraint_always_true(constraint):\n  if not isinstance(constraint, parsing.ast.Compare):\n    return False\n  if len(constraint.ops) != 1 or len(constraint.comparators) != 1:\n    return False\n\n  diff = parsing.ast.BinOp(\n    left=constraint.left, op=parsing.ast.Sub(), right=constraint.comparators[0]\n  )\n  a, b = parsing.linearize_ast(diff)\n  if a != 0.0:\n    return False\n\n  op = constraint.ops[0]\n  if isinstance(op, parsing.ast.GtE):\n    return b >= 0.0\n  if isinstance(op, parsing.ast.Gt):\n    return b > 0.0\n  if isinstance(op, parsing.ast.LtE):\n    return b <= 0.0\n  if isinstance(op, parsing.ast.Lt):\n    return b < 0.0\n  if isinstance(op, parsing.ast.Eq):\n    return b == 0.0\n  return False\n\ndef _solve_linear_inequality_from_coeffs(a, b, op):\n  """\n  Solves a*x + b op 0 and returns a list of intervals.\n  """\n  if a == 0:\n    truth = _compare_constant(b, op)\n    return [(-float("inf"), float("inf"), False, False)] if truth else []\n\n  cutoff = -b / a\n  if op == "<":\n    return [(-float("inf"), cutoff, False, False)] if a > 0 else [(cutoff, float("inf"), False, False)]\n  if op == "<=":\n    return [(-float("inf"), cutoff, False, True)] if a > 0 else [(cutoff, float("inf"), True, False)]\n  if op == ">":\n    return [(cutoff, float("inf"), False, False)] if a > 0 else [(-float("inf"), cutoff, False, False)]\n  if op == ">=":\n    return [(cutoff, float("inf"), True, False)] if a > 0 else [(-float("inf"), cutoff, False, True)]\n  raise ValueError("Unsupported inequality operator.")\n\ndef _compare_constant(value, op):\n  if op == "<":\n    return value < 0\n  if op == "<=":\n    return value <= 0\n  if op == ">":\n    return value > 0\n  if op == ">=":\n    return value >= 0\n  raise ValueError("Unsupported inequality operator.")\n\ndef _filter_intervals_by_constraints(intervals, constraints):\n  if not constraints:\n    return intervals\n  filtered = intervals\n  for constraint in constraints:\n    constraint_intervals = _constraint_to_intervals(constraint)\n    filtered = _intersect_interval_lists(filtered, constraint_intervals)\n    if not filtered:\n      break\n  return filtered\n\ndef _pick_sample(low, high):\n  if low == -float("inf") and high == float("inf"):\n    return 0.0\n  if low == -float("inf"):\n    return high - 1.0\n  if high == float("inf"):\n    return low + 1.0\n  return (low + high) / 2.0\n\ndef _constraint_to_intervals(constraint):\n  if not isinstance(constraint, parsing.ast.Compare):\n    raise ValueError("Expected Compare node.")\n  if len(constraint.ops) != 1 or len(constraint.comparators) != 1:\n    raise ValueError("Only single comparisons supported.")\n\n  diff = parsing.ast.BinOp(\n    left=constraint.left, op=parsing.ast.Sub(), right=constraint.comparators[0]\n  )\n  a, b = parsing.linearize_ast(diff)\n  op = constraint.ops[0]\n  if isinstance(op, parsing.ast.Lt):\n    return _solve_linear_inequality_from_coeffs(a, b, "<")\n  if isinstance(op, parsing.ast.LtE):\n    return _solve_linear_inequality_from_coeffs(a, b, "<=")\n  if isinstance(op, parsing.ast.Gt):\n    return _solve_linear_inequality_from_coeffs(a, b, ">")\n  if isinstance(op, parsing.ast.GtE):\n    return _solve_linear_inequality_from_coeffs(a, b, ">=")\n  if isinstance(op, parsing.ast.Eq):\n    roots = solve_linear_from_coeffs(a, b)\n    if roots == ["ALL_REAL_NUMBERS"]:\n      return [(-float("inf"), float("inf"), False, False)]\n    return [(r, r, True, True) for r in roots if isinstance(r, (int, float))]\n  raise ValueError("Unsupported comparison.")\n\ndef _intersect_interval_lists(a_list, b_list):\n  result = []\n  for a in a_list:\n    for b in b_list:\n      hit = _intersect_intervals(a, b)\n      if hit is not None:\n        result.append(hit)\n  return _merge_intervals(result)\n\ndef _intersect_intervals(a, b):\n  a_low, a_high, a_inc_low, a_inc_high = a\n  b_low, b_high, b_inc_low, b_inc_high = b\n\n  low = max(a_low, b_low)\n  high = min(a_high, b_high)\n  if low > high:\n    return None\n  if low == high:\n    inc = _is_inclusive_at(low, a_low, a_inc_low, a_high, a_inc_high) and _is_inclusive_at(\n      low, b_low, b_inc_low, b_high, b_inc_high\n    )\n    return (low, high, inc, inc) if inc else None\n\n  inc_low = _is_inclusive_at(low, a_low, a_inc_low, a_high, a_inc_high) and _is_inclusive_at(\n    low, b_low, b_inc_low, b_high, b_inc_high\n  )\n  inc_high = _is_inclusive_at(\n    high, a_low, a_inc_low, a_high, a_inc_high\n  ) and _is_inclusive_at(high, b_low, b_inc_low, b_high, b_inc_high)\n  return (low, high, inc_low, inc_high)\n\ndef _is_inclusive_at(value, low, inc_low, high, inc_high):\n  if value == low:\n    return inc_low\n  if value == high:\n    return inc_high\n  return True\n\ndef _merge_intervals(intervals, eps=1e-9):\n  if not intervals:\n    return []\n  intervals.sort(key=lambda x: x[0])\n  merged = [intervals[0]]\n  for low, high, inc_low, inc_high in intervals[1:]:\n    last_low, last_high, last_inc_low, last_inc_high = merged[-1]\n    if low <= last_high + eps:\n      merged[-1] = (\n        last_low,\n        max(last_high, high),\n        last_inc_low,\n        last_inc_high or inc_high,\n      )\n    else:\n      merged.append((low, high, inc_low, inc_high))\n  return merged\n\ndef _fmt_number(value):\n  if abs(value) < 1e-9:\n    return "0"\n  if float(value).is_integer():\n    return str(int(value))\n  return str(value)\n\ndef _fmt_complex(value):\n  real = value.real\n  imag = value.imag\n  if abs(imag) < 1e-9:\n    return _fmt_number(real)\n  has_real = abs(real) >= 1e-9\n  real_text = _fmt_number(real) if has_real else ""\n  imag_mag = abs(imag)\n  imag_text = "" if abs(imag_mag - 1.0) < 1e-9 else _fmt_number(imag_mag)\n  sign = "+" if imag >= 0 else "-"\n  if not has_real:\n    return f"{sign}{imag_text}i" if sign == "-" else f"{imag_text}i"\n  return f"{real_text} {sign} {imag_text}i"\n\ndef _dedupe_and_sort(results, eps=1e-9):\n  if not results:\n    return []\n\n  if "ALL_REAL_NUMBERS" in results:\n    return ["ALL_REAL_NUMBERS"]\n\n  numeric = [r for r in results if isinstance(r, (int, float))]\n  if not numeric:\n    return []\n\n  numeric.sort()\n  deduped = [numeric[0]]\n  for value in numeric[1:]:\n    if abs(value - deduped[-1]) > eps:\n      deduped.append(value)\n\n  return [utils.fix_zero(v) for v in deduped]\n\ndef solve_linear_from_coeffs(a, b):\n    """\n    Solves a*x + b = 0\n    """\n    # Handles the three linear cases: single root, identity, or no solution.\n    if a != 0:\n        return [-b / a]\n    if b == 0:\n        return ["ALL_REAL_NUMBERS"]\n    return []\n\ndef solve_linear_system(equations):\n  """\n  Solves a linear system of equations with multiple variables.\n  equations: list of strings like ["2x + y = 3", "x - y = 1"].\n  Returns a dict mapping variable name to value.\n  """\n  if not equations:\n    raise ValueError("No equations provided.")\n\n  coeff_rows = []\n  constants = []\n  variables = set()\n\n  for eq in equations:\n    lhs, rhs = parsing.split_equation(eq)\n    lhs_ast = parsing.parse_expr(lhs)\n    rhs_ast = parsing.parse_expr(rhs)\n    cL, kL = parsing.linearize_multi_ast(lhs_ast)\n    cR, kR = parsing.linearize_multi_ast(rhs_ast)\n    coeffs = {}\n    for key, val in cL.items():\n      coeffs[key] = coeffs.get(key, 0.0) + val\n    for key, val in cR.items():\n      coeffs[key] = coeffs.get(key, 0.0) - val\n    const = kL - kR\n    coeff_rows.append(coeffs)\n    constants.append(-const)\n    variables.update(coeffs.keys())\n\n  vars_sorted = sorted(variables)\n  n = len(vars_sorted)\n  if len(coeff_rows) != n:\n    raise ValueError("System must have the same number of equations as variables.")\n\n  # Build augmented matrix.\n  matrix = []\n  for coeffs, const in zip(coeff_rows, constants):\n    row = [coeffs.get(v, 0.0) for v in vars_sorted]\n    row.append(const)\n    matrix.append(row)\n\n  # Gaussian elimination.\n  for col in range(n):\n    pivot = col\n    for row in range(col, n):\n      if abs(matrix[row][col]) > abs(matrix[pivot][col]):\n        pivot = row\n    if abs(matrix[pivot][col]) < 1e-12:\n      raise ValueError("System is singular or underdetermined.")\n    if pivot != col:\n      matrix[col], matrix[pivot] = matrix[pivot], matrix[col]\n\n    pivot_val = matrix[col][col]\n    matrix[col] = [val / pivot_val for val in matrix[col]]\n\n    for row in range(n):\n      if row == col:\n        continue\n      factor = matrix[row][col]\n      if abs(factor) < 1e-12:\n        continue\n      matrix[row] = [\n        val - factor * matrix[col][i] for i, val in enumerate(matrix[row])\n      ]\n\n  solution = {var: matrix[i][-1] for i, var in enumerate(vars_sorted)}\n  return solution\n'
quadratic_src = 'import cmath\n\ndef quadratic(a, b, c):\n  """\n  Calculates the roots of a quadratic equation using the quadratic formula.\n\n  Args:\n    a (float): The coefficient of the x^2 term.\n    b (float): The coefficient of the x term.\n    c (float): The constant term.\n\n  Returns:\n    list[complex]: A list containing the two roots (may be complex).\n  """\n  discriminant = (b**2) - (4*a*c)\n  sqr = cmath.sqrt(discriminant)\n  bottom = 2 * a\n  positive = (-b + sqr) / bottom\n  negative = (-b - sqr) / bottom\n  return [positive, negative]\n'
polynomial_src = 'import cmath\n\ndef _eval_poly(coeffs, x):\n  value = 0j\n  for coef in coeffs:\n    value = value * x + coef\n  return value\n\ndef _durand_kerner(coeffs, max_iter=200, tol=1e-12):\n  n = len(coeffs) - 1\n  if n <= 0:\n    return []\n\n  lead = coeffs[0]\n  if lead == 0:\n    raise ValueError("Leading coefficient cannot be zero.")\n\n  # Normalize to monic.\n  coeffs = [c / lead for c in coeffs]\n\n  roots = [cmath.exp(2j * cmath.pi * k / n) for k in range(n)]\n  for _ in range(max_iter):\n    converged = True\n    for i in range(n):\n      prod = 1+0j\n      for j in range(n):\n        if i == j:\n          continue\n        diff = roots[i] - roots[j]\n        if diff == 0:\n          diff = 1e-12 + 1e-12j\n        prod *= diff\n      delta = _eval_poly(coeffs, roots[i]) / prod\n      roots[i] -= delta\n      if abs(delta) > tol:\n        converged = False\n    if converged:\n      break\n  return roots\n\ndef _dedupe_reals(values, eps=1e-7):\n  values.sort()\n  deduped = []\n  for v in values:\n    if not deduped or abs(v - deduped[-1]) > eps:\n      deduped.append(v)\n  return deduped\n\ndef roots(coeffs):\n  """\n  Returns complex roots (decimal approximations) for a polynomial.\n  coeffs: list ordered high-to-low (e.g., [a, b, c] for ax^2+bx+c).\n  """\n  return _durand_kerner(coeffs)\n\ndef real_roots(coeffs):\n  """\n  Returns real roots (decimal approximations) for a polynomial.\n  coeffs: list ordered high-to-low (e.g., [a, b, c] for ax^2+bx+c).\n  """\n  roots = _durand_kerner(coeffs)\n  reals = [r.real for r in roots if abs(r.imag) < 1e-7]\n  return _dedupe_reals(reals)\n'
transcendental_src = 'import math\nimport parsing\n\ndef _sign(value):\n  if value > 0:\n    return 1\n  if value < 0:\n    return -1\n  return 0\n\ndef _bisect(f, a, b, fa, fb, tol=1e-8, max_iter=100):\n  if fa == 0:\n    return a\n  if fb == 0:\n    return b\n  for _ in range(max_iter):\n    mid = (a + b) / 2.0\n    try:\n      fm = f(mid)\n    except (ValueError, ZeroDivisionError):\n      # Domain error: shrink interval.\n      mid = (a + mid) / 2.0\n      try:\n        fm = f(mid)\n      except (ValueError, ZeroDivisionError):\n        mid = (mid + b) / 2.0\n        fm = f(mid)\n    if abs(fm) <= tol:\n      return mid\n    if _sign(fa) * _sign(fm) < 0:\n      b = mid\n      fb = fm\n    else:\n      a = mid\n      fa = fm\n  return (a + b) / 2.0\n\ndef _derivative(f, x, h=1e-5):\n  return (f(x + h) - f(x - h)) / (2 * h)\n\ndef _newton(f, x0, tol=1e-10, max_iter=50):\n  x = x0\n  for _ in range(max_iter):\n    fx = f(x)\n    if abs(fx) <= tol:\n      return x\n    dfx = _derivative(f, x)\n    if dfx == 0:\n      return x\n    x -= fx / dfx\n  return x\n\ndef find_real_roots(expr_ast, xmin=-10.0, xmax=10.0, steps=400, zero_eps=1e-6):\n  def f(x):\n    return parsing.eval_expr_ast(expr_ast, x)\n\n  roots = []\n  step = (xmax - xmin) / steps\n  x0 = xmin\n  try:\n    f0 = f(x0)\n  except (ValueError, ZeroDivisionError):\n    f0 = float("nan")\n  if f0 == 0:\n    roots.append(x0)\n  for i in range(1, steps + 1):\n    x1 = xmin + i * step\n    try:\n      f1 = f(x1)\n    except (ValueError, ZeroDivisionError):\n      f1 = float("nan")\n    if f1 == 0:\n      roots.append(x1)\n    if math.isfinite(f1) and abs(f1) < zero_eps:\n      roots.append(_newton(f, x1))\n    if math.isfinite(f0) and math.isfinite(f1) and _sign(f0) * _sign(f1) < 0:\n      root = _bisect(f, x0, x1, f0, f1)\n      roots.append(root)\n    x0, f0 = x1, f1\n  return roots\n\ndef find_sign_intervals(expr_ast, xmin=-10.0, xmax=10.0, steps=400, zero_eps=1e-6):\n  def f(x):\n    return parsing.eval_expr_ast(expr_ast, x)\n\n  intervals = []\n  step = (xmax - xmin) / steps\n  x0 = xmin\n  try:\n    f0 = f(x0)\n  except (ValueError, ZeroDivisionError):\n    f0 = float("nan")\n\n  for i in range(1, steps + 1):\n    x1 = xmin + i * step\n    try:\n      f1 = f(x1)\n    except (ValueError, ZeroDivisionError):\n      f1 = float("nan")\n\n    if math.isfinite(f0) and math.isfinite(f1):\n      if abs(f0) < zero_eps:\n        intervals.append(("zero", (x0, x0, True, True)))\n      if abs(f1) < zero_eps:\n        intervals.append(("zero", (x1, x1, True, True)))\n      if _sign(f0) * _sign(f1) < 0:\n        root = _bisect(f, x0, x1, f0, f1)\n        intervals.append(("zero", (root, root, True, True)))\n        if _sign(f0) > 0:\n          intervals.append(("pos", (x0, root, False, False)))\n        else:\n          intervals.append(("neg", (x0, root, False, False)))\n        if _sign(f1) > 0:\n          intervals.append(("pos", (root, x1, False, False)))\n        else:\n          intervals.append(("neg", (root, x1, False, False)))\n      else:\n        # Same sign across interval.\n        if _sign(f0) > 0:\n          intervals.append(("pos", (x0, x1, False, False)))\n        elif _sign(f0) < 0:\n          intervals.append(("neg", (x0, x1, False, False)))\n    x0, f0 = x1, f1\n\n  # Merge contiguous intervals; leave points as-is.\n  merged = []\n  for kind, interval in sorted(intervals, key=lambda x: (x[1][0], x[1][1], x[0])):\n    if interval[0] == interval[1]:\n      merged.append((kind, interval))\n      continue\n    if not merged:\n      merged.append((kind, interval))\n      continue\n    last_kind, last = merged[-1]\n    if last[0] == last[1] or last_kind != kind:\n      merged.append((kind, interval))\n      continue\n    if interval[0] <= last[1] + 1e-9:\n      merged[-1] = (kind, (last[0], max(last[1], interval[1]), last[2], interval[3]))\n    else:\n      merged.append((kind, interval))\n  return merged\n\ndef intervals_for_op(expr_ast, op, xmin=-10.0, xmax=10.0, steps=400, zero_eps=1e-6):\n  tagged = find_sign_intervals(expr_ast, xmin, xmax, steps, zero_eps)\n  selected = []\n  for kind, interval in tagged:\n    if op == "<" and kind == "neg":\n      selected.append(interval)\n    elif op == "<=" and kind in ("neg", "zero"):\n      selected.append(interval)\n    elif op == ">" and kind == "pos":\n      selected.append(interval)\n    elif op == ">=" and kind in ("pos", "zero"):\n      selected.append(interval)\n  return selected\n'
nonlinear_src = 'import parsing\n\ndef _solve_linear_system(matrix, tol=1e-12):\n  n = len(matrix)\n  for col in range(n):\n    pivot = col\n    for row in range(col, n):\n      if abs(matrix[row][col]) > abs(matrix[pivot][col]):\n        pivot = row\n    if abs(matrix[pivot][col]) < tol:\n      raise ValueError("Jacobian is singular.")\n    if pivot != col:\n      matrix[col], matrix[pivot] = matrix[pivot], matrix[col]\n\n    pivot_val = matrix[col][col]\n    matrix[col] = [val / pivot_val for val in matrix[col]]\n\n    for row in range(n):\n      if row == col:\n        continue\n      factor = matrix[row][col]\n      if abs(factor) < tol:\n        continue\n      matrix[row] = [\n        val - factor * matrix[col][i] for i, val in enumerate(matrix[row])\n      ]\n  return [row[-1] for row in matrix]\n\ndef solve_nonlinear_system(equations, max_iter=50, tol=1e-8, guess=None, scan=(-2.0, 2.0), scan_steps=3):\n  if not equations:\n    raise ValueError("No equations provided.")\n\n  expr_asts = []\n  variables = set()\n  for eq in equations:\n    lhs, rhs = parsing.split_equation(eq)\n    lhs_ast = parsing.parse_expr(lhs)\n    rhs_ast = parsing.parse_expr(rhs)\n    expr_ast = parsing.ast.BinOp(\n      left=lhs_ast,\n      op=parsing.ast.Sub(),\n      right=rhs_ast,\n    )\n    expr_asts.append(expr_ast)\n    variables.update(parsing.get_variable_names(expr_ast))\n\n  vars_sorted = sorted(variables)\n  n = len(vars_sorted)\n  if len(expr_asts) != n:\n    raise ValueError("System must have the same number of equations as variables.")\n\n  guesses = []\n  if guess is not None:\n    guesses.append([float(guess.get(v, 0.0)) for v in vars_sorted])\n  else:\n    lo, hi = scan\n    if scan_steps < 1:\n      scan_steps = 1\n    if n == 1:\n      for i in range(scan_steps + 1):\n        t = lo + (hi - lo) * (i / scan_steps)\n        guesses.append([t])\n    else:\n      grid = [lo + (hi - lo) * (i / scan_steps) for i in range(scan_steps + 1)]\n      for i in range(len(grid)):\n        for j in range(len(grid)):\n          guesses.append([grid[i], grid[j]])\n\n  def fvec(xvec):\n    env = {v: xvec[i] for i, v in enumerate(vars_sorted)}\n    return [parsing.eval_expr_ast_with_env(expr, env) for expr in expr_asts]\n\n  for start in guesses:\n    x = start[:]\n    for _ in range(max_iter):\n      try:\n        fx = fvec(x)\n      except ValueError:\n        break\n      norm = sum(abs(v) for v in fx)\n      if norm < tol:\n        return {v: x[i] for i, v in enumerate(vars_sorted)}\n\n      # Jacobian via finite differences.\n      jacobian = []\n      for i in range(n):\n        row = []\n        for j in range(n):\n          h = 1e-6 * (1.0 + abs(x[j]))\n          xph = x[:]\n          xph[j] += h\n          try:\n            fph = fvec(xph)[i]\n          except ValueError:\n            fph = fx[i]\n          row.append((fph - fx[i]) / h)\n        row.append(-fx[i])\n        jacobian.append(row)\n\n      try:\n        delta = _solve_linear_system(jacobian)\n      except ValueError:\n        break\n\n      # Damped update.\n      step = 1.0\n      improved = False\n      for _ in range(10):\n        trial = [x[i] + step * delta[i] for i in range(n)]\n        try:\n          trial_norm = sum(abs(v) for v in fvec(trial))\n        except ValueError:\n          trial_norm = float("inf")\n        if trial_norm < norm:\n          x = trial\n          improved = True\n          break\n        step *= 0.5\n      if not improved:\n        break\n\n  raise ValueError("Nonlinear solver did not converge.")\n\ndef solve_nonlinear_system_all(equations, max_iter=50, tol=1e-8, scan=(-2.0, 2.0), scan_steps=3, eps=1e-6):\n  solutions = []\n  expr_asts = []\n  variables = set()\n  for eq in equations:\n    lhs, rhs = parsing.split_equation(eq)\n    lhs_ast = parsing.parse_expr(lhs)\n    rhs_ast = parsing.parse_expr(rhs)\n    expr_ast = parsing.ast.BinOp(\n      left=lhs_ast,\n      op=parsing.ast.Sub(),\n      right=rhs_ast,\n    )\n    expr_asts.append(expr_ast)\n    variables.update(parsing.get_variable_names(expr_ast))\n\n  vars_sorted = sorted(variables)\n  n = len(vars_sorted)\n  if len(expr_asts) != n:\n    raise ValueError("System must have the same number of equations as variables.")\n\n  lo, hi = scan\n  grid = [lo + (hi - lo) * (i / scan_steps) for i in range(scan_steps + 1)]\n  guesses = []\n  if n == 1:\n    for t in grid:\n      guesses.append([t])\n  else:\n    for i in range(len(grid)):\n      for j in range(len(grid)):\n        guesses.append([grid[i], grid[j]])\n\n  def fvec(xvec):\n    env = {v: xvec[i] for i, v in enumerate(vars_sorted)}\n    return [parsing.eval_expr_ast_with_env(expr, env) for expr in expr_asts]\n\n  for start in guesses:\n    x = start[:]\n    for _ in range(max_iter):\n      try:\n        fx = fvec(x)\n      except ValueError:\n        break\n      norm = sum(abs(v) for v in fx)\n      if norm < tol:\n        sol = {v: x[i] for i, v in enumerate(vars_sorted)}\n        if not any(all(abs(sol[k] - s[k]) < eps for k in sol) for s in solutions):\n          solutions.append(sol)\n        break\n\n      jacobian = []\n      for i in range(n):\n        row = []\n        for j in range(n):\n          h = 1e-6 * (1.0 + abs(x[j]))\n          xph = x[:]\n          xph[j] += h\n          try:\n            fph = fvec(xph)[i]\n          except ValueError:\n            fph = fx[i]\n          row.append((fph - fx[i]) / h)\n        row.append(-fx[i])\n        jacobian.append(row)\n\n      try:\n        delta = _solve_linear_system(jacobian)\n      except ValueError:\n        break\n\n      step = 1.0\n      improved = False\n      for _ in range(10):\n        trial = [x[i] + step * delta[i] for i in range(n)]\n        try:\n          trial_norm = sum(abs(v) for v in fvec(trial))\n        except ValueError:\n          trial_norm = float("inf")\n        if trial_norm < norm:\n          x = trial\n          improved = True\n          break\n        step *= 0.5\n      if not improved:\n        break\n\n  if not solutions:\n    raise ValueError("Nonlinear solver did not converge.")\n  return solutions\n'
solve_src = 'import linear\nimport quadratic\nimport parsing\nimport polynomial\nimport transcendental\nimport nonlinear\nfrom typing import cast\n\ndef solve(equation, xmin=None, xmax=None):\n  """\n  Solves equations, inequalities, or systems and returns formatted results.\n\n  Args:\n    equation (str | list[str] | tuple[str, ...]): Equation, inequality, or system.\n    xmin (float, optional): Lower bound for numeric root/interval searches.\n    xmax (float, optional): Upper bound for numeric root/interval searches.\n  """\n  if isinstance(equation, (list, tuple)):\n          if not all(isinstance(e, str) for e in equation):\n                  raise TypeError("All equations must be strings.")\n          try:\n                  solutions = linear.solve_linear_system(equation)\n                  return "{" + ", ".join(f"{k}={v}" for k, v in solutions.items()) + "}"\n          except ValueError:\n                  solutions = nonlinear.solve_nonlinear_system_all(equation)\n                  return "[" + ", ".join("{" + ", ".join(f"{k}={v}" for k, v in sol.items()) + "}" for sol in solutions) + "]"\n  if isinstance(equation, str):\n          # Expand chained equalities into a system.\n          expanded = parsing.split_equalities(equation)\n          if len(expanded) > 1:\n                  return solve(expanded, xmin=xmin, xmax=xmax)\n          if any(op in equation for op in ["<=", ">=", "<", ">"]):\n                  try:\n                          intervals = linear.solve_inequality(equation)\n                          return linear.format_intervals(intervals)\n                  except ValueError:\n                          try:\n                                  constraints = linear.solve_inequality_system(equation)\n                                  return linear.format_halfspaces(constraints)\n                          except ValueError:\n                                  # Transcendental inequality fallback.\n                                  try:\n                                          exprs, ops = parsing.split_inequality(equation)\n                                          expr_asts = [parsing.parse_expr(expr) for expr in exprs]\n                                          intervals = [(-float("inf"), float("inf"), False, False)]\n                                          for idx, op in enumerate(ops):\n                                                  lhs_ast = expr_asts[idx]\n                                                  rhs_ast = expr_asts[idx + 1]\n                                                  expr_ast = parsing.ast.BinOp(\n                                                          left=cast(parsing.ast.expr, lhs_ast),\n                                                          op=parsing.ast.Sub(),\n                                                          right=cast(parsing.ast.expr, rhs_ast),\n                                                  )\n                                                  sign_intervals = transcendental.intervals_for_op(\n                                                          expr_ast, op, xmin or -10.0, xmax or 10.0\n                                                  )\n                                                  intervals = linear._intersect_interval_lists(intervals, sign_intervals)\n                                          return linear.format_intervals(intervals)\n                                  except ValueError:\n                                          pass\n\n          # Try quadratic form first when possible.\n          lhs, rhs = parsing.split_equation(equation)\n          lhs_ast = parsing.parse_expr(lhs)\n          rhs_ast = parsing.parse_expr(rhs)\n          expr_ast = parsing.ast.BinOp(\n                  left=cast(parsing.ast.expr, lhs_ast),\n                  op=parsing.ast.Sub(),\n                  right=cast(parsing.ast.expr, rhs_ast),\n          )\n          vars_found = parsing.get_variable_names(expr_ast)\n          if len(vars_found) > 1:\n                  raise ValueError("Multiple variables are not supported in a single equation.")\n          if len(vars_found) == 1 and "x" not in vars_found:\n                  var_name = next(iter(vars_found))\n                  expr_ast = parsing.replace_variable(expr_ast, var_name, "x")\n          try:\n                  coeffs = parsing.polynomialize_ast(expr_ast)\n                  while len(coeffs) > 1 and abs(coeffs[-1]) < 1e-12:\n                          coeffs.pop()\n                  degree = len(coeffs) - 1\n                  if degree >= 2:\n                          if degree == 2:\n                                  roots = quadratic.quadratic(coeffs[2], coeffs[1], coeffs[0])\n                          else:\n                                  roots = polynomial.roots(list(reversed(coeffs)))\n                          if any(abs(r.imag) > 1e-7 for r in roots):\n                                  return linear.format_complex_solutions(roots)\n                          return linear.format_solutions([r.real for r in roots])\n          except ValueError:\n                  pass\n\n          # Fallback to transcendental root finding.\n          try:\n                  roots = transcendental.find_real_roots(expr_ast, xmin or -10.0, xmax or 10.0)\n                  return linear.format_solutions(roots)\n          except ValueError:\n                  pass\n\n          # Final fallback: linear solver for single-variable equations.\n          solutions = linear.solve_linear(equation)\n          return linear.format_solutions(solutions)\n  else:\n      raise TypeError("Unsupported equation type")\n'
def _load_module(name, src):
    mod = types.ModuleType(name)
    sys.modules[name] = mod
    exec(src, mod.__dict__)
    return mod

_loaded = {}
_loaded['utils'] = _load_module('utils', utils_src)
_loaded['parsing'] = _load_module('parsing', parsing_src)
_loaded['linear'] = _load_module('linear', linear_src)
_loaded['quadratic'] = _load_module('quadratic', quadratic_src)
_loaded['polynomial'] = _load_module('polynomial', polynomial_src)
_loaded['transcendental'] = _load_module('transcendental', transcendental_src)
_loaded['nonlinear'] = _load_module('nonlinear', nonlinear_src)
_loaded['solve'] = _load_module('solve', solve_src)
solve = _loaded['solve'].solve
__all__ = ['solve']
